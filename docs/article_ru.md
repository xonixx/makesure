# Makesure
## 1. What is it?
## 2. Motivation
## 3. Idempotence

## 4. Why awk? - better shell

AWK - интерпретируемый язык. Он очень минималистичный.
Скудный минимум фич включает строки, числа, функции, ассоциативные массивы, построчный I/O.
Пожалуй, можно сказать что он содержит тот минимум фич меньше которого на нём невозможно было бы вовсе программировать.
Каноническая и очень увлекательная [книжка](https://ia903404.us.archive.org/0/items/pdfy-MgN0H1joIoDVoIC7/The_AWK_Programming_Language.pdf) за авторством всей тройки A, W и K cоздателей, которая вышла в далёком 1988 году, но совершенно не потеряла актуальности.

> Read The AWK Programming Language, a joy to read, one of the finest docs ever written, I reckon.

Освежить основы AWK можно в статье [Awk in 20 Minutes](https://ferd.ca/awk-in-20-minutes.html).

Бытует мнение, что Awk мало подходит для написания серьезных программ. Даже Брайан Керниган (K в AWK) убеждён что его язык хорош лишь для маленьких однострочных программ.
Однако, это не мешает энтузиастам создавать на awk весьма объемные программы:
- [Translate shell](https://github.com/soimort/translate-shell)
- [Компилятор](https://news.ycombinator.com/item?id=13452043)
- Эмулятор CPU TODO

Представляют интерес также следующие эксперименты:

- [Реализация Git](https://github.com/djanderson/aho)
- [Awklisp](https://github.com/darius/awklisp)
- [Awkprolog](https://github.com/prolog8/awkprolog)

И тому есть простое объяснение. Минимум фич раскрепощает творчество. Когда есть только один способ сделать что-то, то не тратишь много времени на выбор этого самого способа, а концентрируешься на реализации чистой идеи. Нет соблазна добавлять лишние и зачастую ненужные абстракции, просто потому что при таких ограничениях их практически невозможно реализовать. Кроме того, присутствует спортивный азарт - неужели можно даже на таком языке написать что-то функциональное.

Как это не удивительно, чаще всего на Awk действительно можно продвинуться очень далеко. Многие кто пробовал говорили, что были удивлены как хорошо работал прототип на Awk. Так, что даже не было особого смысла переписывать его на какой-то более традиционный язык программирования.

В принципе, я склонен разделять это мнение и даже готов заявить, что там где можно обойтись Awk-ом, не нужно привлекать Python, Ruby или Nodejs. Ибо, как говорят, хороший программист использует самый мощный инструмент для задачи, а хакер - самый наименее мощный, который приводит к цели.

Лично я пришел к выводу, что AWK удивительно хорошо подходит на замену shell-скриптам размера больше среднего.
Почему?

1. Портабельность (AWK - [часть POSIX стандарта](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html)). Наверное, Python в этом смысле будет [самой выразительной противоположностью](https://xkcd.com/1987/). Да и самих шеллов тоже много будет. Либо более функциональные, но менее универсальные bash/zsh либо стандартный, но менее богатый на фичи POSIX sh, либо крутой, но нестандартный fish.
2. Очень чистый Си-подобный синтаксиc
3. Мощные ассоциативные массивы
4. Мощные функции работы со строками
5. Простая интероперабельность с shell. Хоть ядро AWK очень мало, но вся мощь стандартных утилит *nix в вашем распоряжении.
6. Язык весьма минималистичный и не-избыточный, не меняющийся с, наверное, года 1985. Поэтому прочитав даже [каноническую книгу](https://ia903404.us.archive.org/0/items/pdfy-MgN0H1joIoDVoIC7/The_AWK_Programming_Language.pdf), упомянутую выше можно быть уверенным, что знаешь весь язык. Вряд ли кто-то осмелится сказать подобное даже про POSIX sh.

Ту же мысль доносит и [блог пост](https://blog.jpalardy.com/posts/why-learn-awk/) - другими словами и гораздо более талантливо, но смысл тот же.

### Links

- [The state of the AWK](https://lwn.net/Articles/820829/)


## 5. Interesting facts of awk: no GC, etc.

Удивительно, но язык AWK для своей реализации не требует GC. Впрочем, как и sh/bash.

Секрет тут в том, что в языке, грубо говоря, просто отсутствует возможность делать 'new'. Так, ассоциативный массив объявляется просто фактом использования соответствующей переменной 'как массива'.

```awk
arr["a"] = "b"
```

Знатокам Perl эта особенность может быть известна как [Autovivification](https://en.wikipedia.org/wiki/Autovivification). Вообще, AWK совершенно однозначно является прообразом Perl'а. Можно даже сказать, что Perl это такой себе AWK-переросток на стероидах... Впрочем, мы отклонились.

Аналогично, переменная, с которой обращаются как с числом (`i++`) будет как-бы неявно объявлена числовым типом, и т.д.
Сделано это, очевидно, для того чтобы можно было писать как можно более компактный код в однострочниках, для чего многие из нас и привыкли использовать Awk.

Также из функции запрещено возвращать массив, можно только скалярное значение.

```awk
function f() {
  a[1] = 2
  return a # error
}

```
Но, можно передавать массив в функцию и заполнять его там

```awk
BEGIN { 
  fill(arr)
  print arr[0] " " arr[1] 
}
function fill(arr,   i) { arr[i++] = "hello"; arr[i++] = "world" }
```

Еще одна интересная особенность. Все переменные по умолчанию глобальны. Однако, если добавить переменную в параметры функции (как `i` выше) - она станет локальной. Javascript работает похожим образом, хотя там есть еще `var`/`let`/`const`.
На практике принято отделять "реальные" параметры функции от "локальных" дополнительными пробелами для понятности.

Собственно, использование локальных переменных является механизмом автоматического освобождения ресурсов. Небольшой [пример](https://github.com/xonixx/gron.awk/blob/main/gron.awk#L81).
```awk
function NUMBER(    res) {
  return (tryParse1("-", res) || 1) &&
    (tryParse1("0", res) || tryParse1("123456789", res) && (tryParseDigits(res)||1)) &&
    (tryParse1(".", res) ? tryParseDigits(res) : 1) &&
    (tryParse1("eE", res) ? (tryParse1("-+",res)||1) && tryParseDigits(res) : 1) &&
    asm("number") && asm(res[0])
}
```

В функции `NUMBER` происходит разбор числа. `res` является временным массивом, который будет удалён при выходе из функции автоматически.


Еще из интересного.

```
$ node -e 'function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; console.info(sum(100000))'
[eval]:1
function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; console.info(sum(100000))
                  ^

RangeError: Maximum call stack size exceeded
    at sum ([eval]:1:19)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
```

Тот же Gawk прожует миллион и не поперхнется:

```
$ gawk 'function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; BEGIN { print sum(1000000) }'
500000500000
```

Кстати, GAWK [поддерживает](https://blog.0branch.com/posts/2016-05-13-awk-tco.html) хвостовую оптимизацию.

---

О синтаксисе/грамматике AWK.

## 6. IntelliJ-awk
## 7. Dog fooding
## 8. Testing in different awks, goawk
## 9. Design principles, why Turing completeness is not good
## 10. Alternatives overview
## 11. Process of designing features: script -> lib, goal_glob -> glob
## 12. Parsing in Awk vs reparsing. On importance of starting limited
## 13. Ms time precision on BSD problem. Rant on BSD
## 14. On necessity of awk compilation build step (cat in shellExec)

## 15. Design of `@define`

Многие ли из вас используют всевозможные вспомогательные shell-скрипты в своих проектах? Это также могут быть Python или Perl скрипты. Обычно такие скрипты используются на этапе сборки или для других задач автоматизации процесса разработки проекта. TODO примеры?
Впрочем, часто для подобных целей используют системы сборки.
[Make](https://en.wikipedia.org/wiki/Make_(software)) - пожалуй, наиболее известный из подобных инструментов.
Похожий функционал известен разработчикам nodejs и любим ими в виде скриптов в package.json (npm run-scripts). Ветераны Java вспомнят Ant.

Но nodejs/Ant требуют установки, make хоть и способен выполнять функции ‘task runner’ довольно неудобен в этой роли, будучи на самом деле очень олдскульным ‘build tool’ со многими вытекающими «особенностями».
А shell-скрипты требуют некоторой необходимой системы и рутины в написании (обработка аргументов, help-сообщения и тд).
Хотя, например, [Taskfile](https://github.com/adriancooney/Taskfile) представляет прекрасный шаблон для подобных скриптов.

Так и родился [makesure](https://github.com/xonixx/makesure).

Что это? Это инструмент, который может работать с файлом `Makesurefile` такого формата:

```
@goal downloaded
@doc downloads code archive
@reached_if [[ -f code.tar.gz ]]
  wget http://domain/code.tar.gz
  
@goal extracted
@depends_on downloaded
  tar xzf code.tar.gz 

@goal built
@doc builds the project
@depends_on extracted
  npm install
  npm run build

@goal deployed
@doc deploys the built project
@depends_on built
  scp -C -r build/* user@domain:~/www

@goal default
@depends_on deployed
```

По сути это поименованные кусочки shell (называемые целями), объединённые в одном файле. Это позволяет легко перечислить цели (с пояснительным текстом):
```
$ ./makesure -l
Available goals:
  downloaded : downloads code archive
  extracted
  built      : builds the project
  deployed   : deploys the built project
  default
```
и вызвать любую из них по имени:
```
$ ./makesure deployed
$ ./makesure                  # по умолчанию будет исполнена цель с именем default
```
Да, вот так просто.

Но это ещё не все. Цели могут [декларировать](https://github.com/xonixx/makesure#depends_on) зависимости от других целей и makesure будет учитывать это при выполнении. Это поведение весьма близко к оригинальному make. Цель также может декларировать [условие того что она уже достигнута](https://github.com/xonixx/makesure#reached_if). В этом случае тело цели (соответствующий shell скрипт) уже не будет исполняться. Этот простой механизм позволяет очень удобно и декларативно выражать идемпотентную логику работы, а проще говоря ускорять сборку, так как то что уже выполнено не будет выполняться повторно. Эта фича уже была навеяна идеями из Ansible.

## 16.