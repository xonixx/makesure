# Makesure
## 1. What is it?
## 2. Motivation
## 3. Idempotence

## 4. Why awk? - better shell

AWK - интерпретируемый язык. Он очень минималистичный.
Скудный минимум фич включает строки, числа, функции, ассоциативные массивы, построчный I/O.
Пожалуй, можно сказать что он содержит тот минимум фич меньше которого на нём невозможно было бы вовсе программировать.
Каноническая и очень увлекательная [книжка](https://ia903404.us.archive.org/0/items/pdfy-MgN0H1joIoDVoIC7/The_AWK_Programming_Language.pdf) за авторством всей тройки A, W и K cоздателей, которая вышла в далёком 1988 году, но совершенно не потеряла актуальности.

> Read The AWK Programming Language, a joy to read, one of the finest docs ever written, I reckon.

Освежить основы AWK можно в статье [Awk in 20 Minutes](https://ferd.ca/awk-in-20-minutes.html).

Бытует мнение, что Awk мало подходит для написания серьезных программ. Даже Брайан Керниган (K в AWK) убеждён что его язык хорош лишь для маленьких однострочных программ.
Однако, это не мешает энтузиастам создавать на awk весьма объемные программы:
- [Translate shell](https://github.com/soimort/translate-shell)
- [Компилятор](https://news.ycombinator.com/item?id=13452043)
- Эмулятор CPU TODO

Представляют интерес также следующие эксперименты:

- [Реализация Git](https://github.com/djanderson/aho)
- [Awklisp](https://github.com/darius/awklisp)
- [Awkprolog](https://github.com/prolog8/awkprolog)

И тому есть простое объяснение. Минимум фич раскрепощает творчество. Когда есть только один способ сделать что-то, то не тратишь много времени на выбор этого самого способа, а концентрируешься на реализации чистой идеи. Нет соблазна добавлять лишние и зачастую ненужные абстракции, просто потому что при таких ограничениях их практически невозможно реализовать. Кроме того, присутствует спортивный азарт - неужели можно даже на таком языке написать что-то функциональное.

Как это не удивительно, чаще всего на Awk действительно можно продвинуться очень далеко. Многие кто пробовал говорили, что были удивлены как хорошо работал прототип на Awk. Так, что даже не было особого смысла переписывать его на какой-то более традиционный язык программирования.

В принципе, я склонен разделять это мнение и даже готов заявить, что там где можно обойтись Awk-ом, не нужно привлекать Python, Ruby или Nodejs. Ибо, как говорят, хороший программист использует самый мощный инструмент для задачи, а хакер - самый наименее мощный, который приводит к цели.

Лично я пришел к выводу, что AWK удивительно хорошо подходит на замену shell-скриптам размера больше среднего.
Почему?

1. Портабельность (AWK - [часть POSIX стандарта](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html)). Наверное, Python в этом смысле будет [самой выразительной противоположностью](https://xkcd.com/1987/). Да и самих шеллов тоже много будет. Либо более функциональные, но менее универсальные bash/zsh либо стандартный, но менее богатый на фичи POSIX sh, либо крутой, но нестандартный fish.
2. Очень чистый Си-подобный синтаксиc
3. Мощные ассоциативные массивы
4. Мощные функции работы со строками
5. Простая интероперабельность с shell. Хоть ядро AWK очень мало, но вся мощь стандартных утилит *nix в вашем распоряжении.
6. Язык весьма минималистичный и не-избыточный, не меняющийся с, наверное, года 1985. Поэтому прочитав даже [каноническую книгу](https://ia903404.us.archive.org/0/items/pdfy-MgN0H1joIoDVoIC7/The_AWK_Programming_Language.pdf), упомянутую выше можно быть уверенным, что знаешь весь язык. Вряд ли кто-то осмелится сказать подобное даже про POSIX sh.

Ту же мысль доносит и [блог пост](https://blog.jpalardy.com/posts/why-learn-awk/) - другими словами и гораздо более талантливо, но смысл тот же.

### Links

- [The state of the AWK](https://lwn.net/Articles/820829/)


## 5. Interesting facts of awk: no GC, etc.

Удивительно, но язык AWK для своей реализации не требует GC. Впрочем, как и sh/bash.

Секрет тут в том, что в языке, грубо говоря, просто отсутствует возможность делать 'new'. Так, ассоциативный массив объявляется просто фактом использования соответствующей переменной 'как массива'.

```awk
arr["a"] = "b"
```

Знатокам Perl эта особенность может быть известна как [Autovivification](https://en.wikipedia.org/wiki/Autovivification). Вообще, AWK совершенно однозначно является прообразом Perl'а. Можно даже сказать, что Perl это такой себе AWK-переросток на стероидах... Впрочем, мы отклонились.

Аналогично, переменная, с которой обращаются как с числом (`i++`) будет как-бы неявно объявлена числовым типом, и т.д.
Сделано это, очевидно, для того чтобы можно было писать как можно более компактный код в однострочниках, для чего многие из нас и привыкли использовать Awk.

Также из функции запрещено возвращать массив, можно только скалярное значение.

```awk
function f() {
  a[1] = 2
  return a # error
}

```
Но, можно передавать массив в функцию и заполнять его там

```awk
BEGIN { 
  fill(arr)
  print arr[0] " " arr[1] 
}
function fill(arr,   i) { arr[i++] = "hello"; arr[i++] = "world" }
```

Еще одна интересная особенность. Все переменные по умолчанию глобальны. Однако, если добавить переменную в параметры функции (как `i` выше) - она станет локальной. Javascript работает похожим образом, хотя там есть еще `var`/`let`/`const`.
На практике принято отделять "реальные" параметры функции от "локальных" дополнительными пробелами для понятности.

Собственно, использование локальных переменных является механизмом автоматического освобождения ресурсов. Небольшой [пример](https://github.com/xonixx/gron.awk/blob/main/gron.awk#L81).
```awk
function NUMBER(    res) {
  return (tryParse1("-", res) || 1) &&
    (tryParse1("0", res) || tryParse1("123456789", res) && (tryParseDigits(res)||1)) &&
    (tryParse1(".", res) ? tryParseDigits(res) : 1) &&
    (tryParse1("eE", res) ? (tryParse1("-+",res)||1) && tryParseDigits(res) : 1) &&
    asm("number") && asm(res[0])
}
```

В функции `NUMBER` происходит разбор числа. `res` является временным массивом, который будет удалён при выходе из функции автоматически.


Еще из интересного.

```
$ node -e 'function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; console.info(sum(100000))'
[eval]:1
function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; console.info(sum(100000))
                  ^

RangeError: Maximum call stack size exceeded
    at sum ([eval]:1:19)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
```

Тот же Gawk прожует миллион и не поперхнется:

```
$ gawk 'function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; BEGIN { print sum(1000000) }'
500000500000
```

Кстати, GAWK [поддерживает](https://blog.0branch.com/posts/2016-05-13-awk-tco.html) хвостовую оптимизацию.

---

О синтаксисе/грамматике AWK.

## 6. IntelliJ-awk
## 7. Dog fooding
## 8. Testing in different awks, goawk
## 9. Design principles, why Turing completeness is not good
## 10. Alternatives overview
## 11. Process of designing features: script -> lib, goal_glob -> glob
## 12. Parsing in Awk vs reparsing. On importance of starting limited
## 13. Ms time precision on BSD problem. Rant on BSD
## 14. On necessity of awk compilation build step (cat in shellExec)

## 15. Design of `@define`

Многие ли из вас используют всевозможные вспомогательные shell-скрипты в своих проектах? Это также могут быть Python или Perl скрипты. Обычно такие скрипты используются на этапе сборки или для других задач автоматизации процесса разработки проекта. 

Примерами могут служить: 
- вспомогательные скрипты для Git, 
- запуск тестов/линтеров, 
- запуск необходимых докер контейнеров, 
- запуск БД-миграций,
- собственно, сборка проекта,
- генерация документации,
- автоматизация публикации релизов,
- развертывание и т.д.

Впрочем, часто для подобных целей используют системы сборки.
[Make](https://en.wikipedia.org/wiki/Make_(software)) - пожалуй, наиболее известный из подобных инструментов.
Похожий функционал известен разработчикам nodejs и любим ими в виде скриптов в package.json (npm run-scripts). Ветераны Java вспомнят Ant.

Но nodejs/Ant требуют установки, make хоть и способен выполнять функции ‘task runner’ довольно неудобен в этой роли, будучи на самом деле очень олдскульным ‘build tool’ со многими вытекающими «особенностями».
А shell-скрипты требуют некоторой необходимой системы и рутины в написании (обработка аргументов, help-сообщения и тд).
Хотя, например, [Taskfile](https://github.com/adriancooney/Taskfile) представляет прекрасный шаблон для подобных скриптов.

Так и родился [makesure](https://github.com/xonixx/makesure).

Что это? Это инструмент, который может работать с файлом `Makesurefile` такого формата:

```
@goal downloaded
@doc downloads code archive
@reached_if [[ -f code.tar.gz ]]
  wget http://domain/code.tar.gz
  
@goal extracted
@depends_on downloaded
  tar xzf code.tar.gz 

@goal built
@doc builds the project
@depends_on extracted
  npm install
  npm run build

@goal deployed
@doc deploys the built project
@depends_on built
  scp -C -r build/* user@domain:~/www

@goal default
@depends_on deployed
```

По сути это поименованные кусочки shell (называемые целями), объединённые в одном файле. Это позволяет легко перечислить цели (с пояснительным текстом):
```
$ ./makesure -l
Available goals:
  downloaded : downloads code archive
  extracted
  built      : builds the project
  deployed   : deploys the built project
  default
```
и вызвать любую из них по имени:
```
$ ./makesure deployed
$ ./makesure                  # по умолчанию будет исполнена цель с именем default
```
Да, вот так просто.

Но это ещё не все. Цели могут [декларировать](https://github.com/xonixx/makesure#depends_on) зависимости от других целей и makesure будет учитывать это при выполнении. Это поведение весьма близко к оригинальному make. Цель также может декларировать [условие того что она уже достигнута](https://github.com/xonixx/makesure#reached_if). В этом случае тело цели (соответствующий shell скрипт) уже не будет исполняться. Этот простой механизм позволяет очень удобно и декларативно выражать идемпотентную логику работы, а проще говоря ускорять сборку, так как то что уже выполнено не будет выполняться повторно. Эта фича уже была навеяна идеями из Ansible.
      
Это было вступление. Я же хотел сосредоточиться в этой статье на освещении процесса дизайна одной из фич этого инструмента.

Давайте представим, что мы будем проектировать возможность определения глобальных переменных, доступных всем целям.

Ну, что-то типа

```shell
@define VERSION='1.2.3'
@goal built
  echo "Building $VERSION ..."
@goal tested
  echo "Testing $VERSION ..."
```

Изначально я хотел спроектировать эту часть в наиболее общем виде. Так, я решил, что в инструменте будет понятие prelude - это скрипт, идущий перед всеми декларациями `@goal`. Целью этого скрипта будет инициализация глобальных переменных. Ну какой-нибудь такой гипотетический пример

```shell
# prelude starts
if [ -f version.txt ]
then
  @define VERSION=`cat version.txt`
else
  @define VERSION='0.0.1'
fi
# prelude ends
@goal built
  echo "Building $VERSION ..."
```

Идея была в том чтоб где-то приблизиться по функционалу к `make`, не вводя при этом отдельный язык программирования, а использовать знакомый shell. 

Пару отягчающих моментов. Во-первых, следует принять во внимание, что под капотом каждый из @goal-скриптов выполняется в отдельном процессе shell. Сделано это намеренно, чтобы исключить возможность зависимостей через глобальные переменные между целями, что может сделать логику исполнения более императивной и запутанной. `make` в этом смысле ведет себя подобным образом, а точнее еще "хуже" - там каждая строка исполняется в отдельном shell.  

Во-вторых, хотелось чтобы prelude-скрипт исполнялся только единожды, независимо от того, сколько целей будет исполнено в процессе.
Очевидно, скрипт инициализации может быть ресурсоёмкий, скажем 

```shell
@define VERSION="$(curl -s http://domain/version.txt)"
``` 

В-третьих, должна иметься возможность переопределить значение переменной в момент запуска, например так

```
./makesure -D VERSION=0.0.2 build
```

Первый и второй моменты несколько плохо сочетаются, исключая простую возможность подмешивания скрипта prelude в начале каждого @goal-скрипта как модели исполнения.

В результате решение было все-же найдено, и заключалось оно в том, что каждое вхождение `defile VAR=val` под капотом заменялось на что-то типа `VAR=val; echo "VAR='$VAR'" >> /tmp/makesure_values` а в начало каждого @goal-скрипта неявно добавлялось `. /tmp/makesure_values`.
Были некие дополнительные нюансы, связанные с реализацией третьего пункта, но они не слишком существенны для упоминания.

Как-бы это заработало, но осадочек остался. Как-то неизящно что-ли это всё. Временные файлы явно не пойдут на пользу скорости исполнения, плюс надо делать дополнительные телодвижения чтоб их подчищать.

По поводу скорости, на системах где присутствует [/dev/shm](https://superuser.com/a/45509/682392) (все современные Линуксы?) он был использован вместо `/tmp`. macOS - :-( - там это не поддерживается.

По поводу гарантии подчистки временных файлов - test suite [был доработан](https://github.com/xonixx/makesure/blob/v0.9.14/Makesurefile#L77) таким образом, чтоб падать, если вдруг по какой-то причине мусор не был удалён. 
     
Как это обычно бывает, свежий взгляд со стороны от человека ранее не вовлеченного в дело может быть весьма ценен. 
Так, в какой-то момент мне поступил [pull-request](https://github.com/xonixx/makesure/pull/81/files) с предложением по оптимизации этой части логики. Участник предложил применить более простую логику без временных файлов. Некоторое время я был в недоумении. Как я сам не додумался до этого решения раньше? Однако, погрузившись в некоторые воспоминания, я понял, что мой вариант решения был неслучаен.

Дело в том, что по моему замыслу должна была быть возможность делать так

```shell
A=Hello                # invisible to goals
@define B="$A world"   # visible to goals
```

По моей задумке, достигаться это должно было тем, что в файл `/tmp/makesure_values` должны были попадать уже "вычисленные" @define-значения.
И это принципиально не работало в предложенном участником способе.

Каково же было моё удивление, когда я [обнаружил](https://github.com/xonixx/makesure/pull/81#issuecomment-974904922), что этот кейс не работает и с моей имплементацией!

Первым моим побуждением было устранить эту проблему и покрыть этот случай недостающими тестами.

Однако, вместо этого я [крепко призадумался](https://github.com/xonixx/makesure/pull/81#issuecomment-975958930).
Получается, это та функция, которую даже я сам (автор и основной пользователь инструмента) не использую в моих `Makesurefile` файлах. Иначе я бы уже обнаружил эту проблему.
А что если вообще удалить концепцию prelude как произвольного скрипта перед целями? Оставить только `@define`?
Почему нет? Ведь [less is more](https://en.wikipedia.org/wiki/Minimalism#Software_and_UI_design), а [worse is better](https://en.wikipedia.org/wiki/Worse_is_better).
        
Вот несколько мыслей которыми я руководствовался:

- Эта фича нешироко используется (или вообще не используется) и имеет баги реализации
- Мы еще не знаем как правильно использовать этот функционал. Возможно его неправильное использование/злоупотребление им.
- Вносит неопределенность. Если необходима такая сложная логика инициализации, почему бы не использовать для этого отдельную цель `@goal initialized`?
- Усложняет реализацию и делает её менее производительной за счет использования временных файлов.

Да и вообще при разработке продукта или библиотеки очень важно реализовывать минимально возможный функционал, и именно тот который необходим пользователям сейчас. Весьма часто разработчики поддаются соблазну добавить какие-то очевидные улучшения и функции, которые не критически важны и/или избыточны, просто потому что это кажется простым. Более того, по этой же причине часто полезно явно исключить определенные фичи/сценарии использования. Потому что вы всегда можете их добавить позже, если будет явный запрос от пользователей. Удалить же какую-то неудачную фичу может быть гораздо более проблематично. 
   
Решено. Урезаем концепцию prelude, оставляем лишь возможность `@define`.

Однако на этом вопросы не заканчиваются.

- Возможно также есть смысл переработать синтаксис:
    - `@define VAR='hello'` (как сейчас) vs
    - `@define VAR 'hello'` (более консистентно с синтаксисом остальных директив)
    - Разрешить или запретить строки с двойными кавычками? Другими словами, хотим ли мы поддерживать подстановку переменных:
        - `@define W=world`
        - `@define HW="Hello $W!"`
- Реализация
    - pass-thru в shell (как сейчас)
        - Гибкость с подстановкой переменных, но труднее с валидацией
    - или ручной парсинг
        - Сложнее в реализации, но больший контроль в валидации неинициализированных переменных, можем запретить функции shell, например `@define A="$(curl https://google.com)"`

Дело в том, что текущая реализация, как уже говорилось выше, основана на, буквально, передаче всего что идёт после слова `@define` на исполнение в shell. А это значит, что можно написать 
```shell
@define echo 'Hello'
```
и оно не выдаст ошибку, но сделает какую-то несанкционированную ерунду.

Если попытаться добавить простенькую регулярку на соответствие `VARNAME=`, то и это легко обойти

```shell
@define A=aaa echo 'Hello' # будет вызвана команда echo у которой задана переменная окружения A
```

Естественно, хотелось бы запретить такие "возможности".

Имеем дилемму. Либо же отказываемся от передачи в shell и добавляем ad-hoc парсер этой директивы или же имеем что имеем.

Специальный парсер был бы хорошим вариантом, если бы не чрезвычайная сложность, которую нужно добавить. 

Знаете ли вы сколькими способами в Bash можно определить переменную со значением `hello world`?
              
```
H=hello\ world
H='hello world'
H=$'hello world'
H="hello world"
W=world
H="hello $W"
H=hello\ $W
H='hello '$W
H='hello'\ $W
H=$'hello '"world"
H='hello'$' world'
H=$'hello'\ $' world'
H='hello'$' '"world"
H='hello world';
H="hello world" # with comment
H=$'hello world'     ;            # with semicolon, spaces and comment
# и т.д.
```

И это еще далеко не все варианты! 

Почему дополнительная сложность реализации неприемлема? Потому что один из фундаментальных принципов, которые я положил в основу этого инструмента, это [worse is better](https://en.wikipedia.org/wiki/Worse_is_better). Это значит что простота реализации и минимальный размер утилиты более предпочтительны, чем богатая функциональность.


Вы можете спросить - а зачем вообще полагаться на синтаксис bash? Почему бы не ввести свой ограниченный синтаксис, скажем как-нибудь так

```
@define H  'hello'
@define HW 'hello {{world}}'
```

Идея заманчива, но не лишена недостатков, так как привносит усложнение ментальной сложности инструмента. 
Дело в том, что инструмент спроектирован таким образом, что его синтаксис полностью укладывается в синтаксис shell. Это чрезвычайно удобно, так как вы можете выбрать в своей IDE подсветку shell для `Makesurefile` и [это будет работать](https://github.com/xonixx/makesure/blob/main/Makesurefile)! Но это также значит, что необходимо, чтоб все синтаксические конструкции несли тот же смысл, что и в shell. Очевидно, что логика подстановки значений в гипотетическом облегченном синтаксисе не соответствует модели shell и это придется дополнительно знать пользователю.

Вообще убрать возможность подстановки переменных было бы тоже вариантом. Но оказалось, что те немногие, кто уже использует makesure, включая меня самого, уже [полагаются](https://github.com/xonixx/makesure/pull/81#issuecomment-976174461) на эту возможность.
     
Результатом тягостных раздумий явилось компромиссное решение. Мы по-прежнему передаём строку на исполнение в shell, но перед этим валидируем её бережно написанной [регуляркой](https://github.com/xonixx/makesure/blob/v0.9.16/makesure.awk#L154). Да, я знаю, что [парсить регулярками нельзя](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454). Но мы и не парсим! Мы только отсекаем невалидные варианты, а парсит shell. Интересный момент. На самом деле, эта регулярка более строгая, чем парсер shell:

```shell
@define VERSION=1.2.3    # makesure won't accept
@define VERSION='1.2.3'  # OK

@define HW=${HELLO}world    # makesure won't accept  
@define HW="${HELLO}world"  # OK  
```

Что я нахожу даже плюсом, т.к. это более консистентно.

В остальном эта директива хорошо покрыта тестами - как то, [что должно парситься](https://github.com/xonixx/makesure/blob/v0.9.16/tests/16_define_validation.sh), так и то, [что не должно](https://github.com/xonixx/makesure/blob/v0.9.16/tests/16_define_validation_error.sh).

Подытожим. Спроектировали фичу. Потом перепроектировали, при этом смогли упростить и уменьшить код, ускорить его и при этом добавить дополнительные проверки. 

На этом, пожалуй, стоит остановить свое повествование.

Заинтересовавшихся приглашаю опробовать утилиту [makesure](https://github.com/xonixx/makesure) в своих проектах.
Тем более, что она не требует инсталляции [(как это?)](https://github.com/xonixx/makesure#installation) и [хорошо портабельна](https://github.com/xonixx/makesure#os).

## 16.