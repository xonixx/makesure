# Makesure
## 1. What is it?
## 2. Motivation
## 3. Idempotence

## 4. Why awk? - better shell

AWK - интерпретируемый язык. Он очень минималистичный.
Скудный минимум фич включает строки, числа, функции, ассоциативные массивы, построчный I/O.
Пожалуй, можно сказать что он содержит тот минимум фич меньше которого на нём невозможно было бы вовсе программировать.
Каноническая и очень увлекательная [книжка](https://ia903404.us.archive.org/0/items/pdfy-MgN0H1joIoDVoIC7/The_AWK_Programming_Language.pdf) за авторством всей тройки A, W и K cоздателей, которая вышла в далёком 1988 году, но совершенно не потеряла актуальности.

> Read The AWK Programming Language, a joy to read, one of the finest docs ever written, I reckon.

Освежить основы AWK можно в статье [Awk in 20 Minutes](https://ferd.ca/awk-in-20-minutes.html).

Бытует мнение, что Awk мало подходит для написания серьезных программ. Даже Брайан Керниган (K в AWK) убеждён что его язык хорош лишь для маленьких однострочных программ.
Однако, это не мешает энтузиастам создавать на awk весьма объемные программы:
- [Translate shell](https://github.com/soimort/translate-shell)
- [Компилятор](https://news.ycombinator.com/item?id=13452043)
- Эмулятор CPU TODO

Представляют интерес также следующие эксперименты:

- [Реализация Git](https://github.com/djanderson/aho)
- [Awklisp](https://github.com/darius/awklisp)
- [Awkprolog](https://github.com/prolog8/awkprolog)

И тому есть простое объяснение. Минимум фич раскрепощает творчество. Когда есть только один способ сделать что-то, то не тратишь много времени на выбор этого самого способа, а концентрируешься на реализации чистой идеи. Нет соблазна добавлять лишние и зачастую ненужные абстракции, просто потому что при таких ограничениях их практически невозможно реализовать. Кроме того, присутствует спортивный азарт - неужели можно даже на таком языке написать что-то функциональное.

Как это не удивительно, чаще всего на Awk действительно можно продвинуться очень далеко. Многие кто пробовал говорили, что были удивлены как хорошо работал прототип на Awk. Так, что даже не было особого смысла переписывать его на какой-то более традиционный язык программирования.

В принципе, я склонен разделять это мнение и даже готов заявить, что там где можно обойтись Awk-ом, не нужно привлекать Python, Ruby или Nodejs. Ибо, как говорят, хороший программист использует самый мощный инструмент для задачи, а хакер - самый наименее мощный, который приводит к цели.

Лично я пришел к выводу, что AWK удивительно хорошо подходит на замену shell-скриптам размера больше среднего.
Почему?

1. Портабельность (AWK - [часть POSIX стандарта](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html)). Наверное, Python в этом смысле будет [самой выразительной противоположностью](https://xkcd.com/1987/). Да и самих шеллов тоже много будет. Либо более функциональные, но менее универсальные bash/zsh либо стандартный, но менее богатый на фичи POSIX sh, либо крутой, но нестандартный fish.
2. Очень чистый Си-подобный синтаксиc
3. Мощные ассоциативные массивы
4. Мощные функции работы со строками
5. Простая интероперабельность с shell. Хоть ядро AWK очень мало, но вся мощь стандартных утилит *nix в вашем распоряжении.
6. Язык весьма минималистичный и не-избыточный, не меняющийся с, наверное, года 1985. Поэтому прочитав даже [каноническую книгу](https://ia903404.us.archive.org/0/items/pdfy-MgN0H1joIoDVoIC7/The_AWK_Programming_Language.pdf), упомянутую выше можно быть уверенным, что знаешь весь язык. Вряд ли кто-то осмелится сказать подобное даже про POSIX sh.

Ту же мысль доносит и [блог пост](https://blog.jpalardy.com/posts/why-learn-awk/) - другими словами и гораздо более талантливо, но смысл тот же.

### Links

- [The state of the AWK](https://lwn.net/Articles/820829/)


## 5. Interesting facts of awk: no GC, etc.

Удивительно, но язык AWK для своей реализации не требует GC. Впрочем, как и sh/bash.

Секрет тут в том, что в языке, грубо говоря, просто отсутствует возможность делать 'new'. Так, ассоциативный массив объявляется просто фактом использования соответствующей переменной 'как массива'.

```awk
arr["a"] = "b"
```

Знатокам Perl эта особенность может быть известна как [Autovivification](https://en.wikipedia.org/wiki/Autovivification). Вообще, AWK совершенно однозначно является прообразом Perl'а. Можно даже сказать, что Perl это такой себе AWK-переросток на стероидах... Впрочем, мы отклонились.

Аналогично, переменная, с которой обращаются как с числом (`i++`) будет как-бы неявно объявлена числовым типом, и т.д.
Сделано это, очевидно, для того чтобы можно было писать как можно более компактный код в однострочниках, для чего многие из нас и привыкли использовать Awk.

Также из функции запрещено возвращать массив, можно только скалярное значение.

```awk
function f() {
  a[1] = 2
  return a # error
}

```
Но, можно передавать массив в функцию и заполнять его там

```awk
BEGIN { 
  fill(arr)
  print arr[0] " " arr[1] 
}
function fill(arr,   i) { arr[i++] = "hello"; arr[i++] = "world" }
```

Еще одна интересная особенность. Все переменные по умолчанию глобальны. Однако, если добавить переменную в параметры функции (как `i` выше) - она станет локальной. Javascript работает похожим образом, хотя там есть еще `var`/`let`/`const`.
На практике принято отделять "реальные" параметры функции от "локальных" дополнительными пробелами для понятности.

Собственно, использование локальных переменных является механизмом автоматического освобождения ресурсов. Небольшой [пример](https://github.com/xonixx/gron.awk/blob/main/gron.awk#L81).
```awk
function NUMBER(    res) {
  return (tryParse1("-", res) || 1) &&
    (tryParse1("0", res) || tryParse1("123456789", res) && (tryParseDigits(res)||1)) &&
    (tryParse1(".", res) ? tryParseDigits(res) : 1) &&
    (tryParse1("eE", res) ? (tryParse1("-+",res)||1) && tryParseDigits(res) : 1) &&
    asm("number") && asm(res[0])
}
```

В функции `NUMBER` происходит разбор числа. `res` является временным массивом, который будет удалён при выходе из функции автоматически.


Еще из интересного.

```
$ node -e 'function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; console.info(sum(100000))'
[eval]:1
function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; console.info(sum(100000))
                  ^

RangeError: Maximum call stack size exceeded
    at sum ([eval]:1:19)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
    at sum ([eval]:1:43)
```

Тот же Gawk прожует миллион и не поперхнется:

```
$ gawk 'function sum(n) { return n == 0 ? 0 : n + sum(n-1) }; BEGIN { print sum(1000000) }'
500000500000
```

Кстати, GAWK [поддерживает](https://blog.0branch.com/posts/2016-05-13-awk-tco.html) хвостовую оптимизацию.

---

О синтаксисе/грамматике AWK.

## 6. IntelliJ-awk
## 7. Dog fooding
## 8. Testing in different awks, goawk
## 9. Design principles, why Turing completeness is not good
## 10. Alternatives overview
## 11. Process of designing features: script -> lib, goal_glob -> glob
## 12. Parsing in Awk vs reparsing. On importance of starting limited
## 13. Ms time precision on BSD problem. Rant on BSD
## 14. On necessity of awk compilation build step (cat in shellExec)
## 15.
## 16.